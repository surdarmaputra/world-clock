/**
 * Generated by orval v6.17.0 üç∫
 * Do not edit manually.
 * World Time API
 * A simple API to get the current time based on a request with a timezone.
 * OpenAPI spec version: 20210108
 */
import type { Key, SWRConfiguration } from 'swr';
import useSwr from 'swr';

import type { ErrorType } from '../../../utils/request';
import { request } from '../../../utils/request';
import type {
  ErrorJsonResponseResponse,
  ErrorTextResponseResponse,
  SuccessfulDateTimeJsonResponseResponse,
  SuccessfulDateTimeTextResponseResponse,
  SuccessfulListJsonResponseResponse,
  SuccessfulListTextResponseResponse,
} from '../../models';

type SecondParameter<T extends (...args: any) => any> = T extends (
  config: any,
  args: infer P,
) => any
  ? P
  : never;

/**
 * @summary a listing of all timezones.
 */
export const getTimezone = (options?: SecondParameter<typeof request>) => {
  return request<SuccessfulListJsonResponseResponse>(
    { url: '/timezone', method: 'get' },
    options,
  );
};

export const getGetTimezoneKey = () => ['/timezone'] as const;

export type GetTimezoneQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimezone>>
>;
export type GetTimezoneQueryError =
  ErrorType<SuccessfulListJsonResponseResponse>;

/**
 * @summary a listing of all timezones.
 */
export const useGetTimezone = <
  TError = ErrorType<SuccessfulListJsonResponseResponse>,
>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getTimezone>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
  request?: SecondParameter<typeof request>;
}) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getGetTimezoneKey() : null));
  const swrFn = () => getTimezone(requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * @summary a listing of all timezones.
 */
export const getTimezoneTxt = (options?: SecondParameter<typeof request>) => {
  return request<SuccessfulListTextResponseResponse>(
    { url: '/timezone.txt', method: 'get' },
    options,
  );
};

export const getGetTimezoneTxtKey = () => ['/timezone.txt'] as const;

export type GetTimezoneTxtQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimezoneTxt>>
>;
export type GetTimezoneTxtQueryError =
  ErrorType<SuccessfulListTextResponseResponse>;

/**
 * @summary a listing of all timezones.
 */
export const useGetTimezoneTxt = <
  TError = ErrorType<SuccessfulListTextResponseResponse>,
>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getTimezoneTxt>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
  request?: SecondParameter<typeof request>;
}) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getGetTimezoneTxtKey() : null));
  const swrFn = () => getTimezoneTxt(requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * @summary a listing of all timezones available for that area.
 */
export const getTimezoneArea = (
  area: string,
  options?: SecondParameter<typeof request>,
) => {
  return request<SuccessfulListJsonResponseResponse>(
    { url: `/timezone/${area}`, method: 'get' },
    options,
  );
};

export const getGetTimezoneAreaKey = (area: string) =>
  [`/timezone/${area}`] as const;

export type GetTimezoneAreaQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimezoneArea>>
>;
export type GetTimezoneAreaQueryError = ErrorType<ErrorJsonResponseResponse>;

/**
 * @summary a listing of all timezones available for that area.
 */
export const useGetTimezoneArea = <
  TError = ErrorType<ErrorJsonResponseResponse>,
>(
  area: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof getTimezoneArea>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    request?: SecondParameter<typeof request>;
  },
) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!area;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getGetTimezoneAreaKey(area) : null));
  const swrFn = () => getTimezoneArea(area, requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * @summary a listing of all timezones available for that area.
 */
export const getTimezoneAreaTxt = (
  area: string,
  options?: SecondParameter<typeof request>,
) => {
  return request<SuccessfulListTextResponseResponse>(
    { url: `/timezone/${area}.txt`, method: 'get' },
    options,
  );
};

export const getGetTimezoneAreaTxtKey = (area: string) =>
  [`/timezone/${area}.txt`] as const;

export type GetTimezoneAreaTxtQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimezoneAreaTxt>>
>;
export type GetTimezoneAreaTxtQueryError = ErrorType<ErrorTextResponseResponse>;

/**
 * @summary a listing of all timezones available for that area.
 */
export const useGetTimezoneAreaTxt = <
  TError = ErrorType<ErrorTextResponseResponse>,
>(
  area: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof getTimezoneAreaTxt>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    request?: SecondParameter<typeof request>;
  },
) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!area;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getGetTimezoneAreaTxtKey(area) : null));
  const swrFn = () => getTimezoneAreaTxt(area, requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * @summary request the current time for a timezone.
 */
export const getTimezoneAreaLocation = (
  area: string,
  location: string,
  options?: SecondParameter<typeof request>,
) => {
  return request<SuccessfulDateTimeJsonResponseResponse>(
    { url: `/timezone/${area}/${location}`, method: 'get' },
    options,
  );
};

export const getGetTimezoneAreaLocationKey = (area: string, location: string) =>
  [`/timezone/${area}/${location}`] as const;

export type GetTimezoneAreaLocationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimezoneAreaLocation>>
>;
export type GetTimezoneAreaLocationQueryError =
  ErrorType<ErrorJsonResponseResponse>;

/**
 * @summary request the current time for a timezone.
 */
export const useGetTimezoneAreaLocation = <
  TError = ErrorType<ErrorJsonResponseResponse>,
>(
  area: string,
  location: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof getTimezoneAreaLocation>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    request?: SecondParameter<typeof request>;
  },
) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!(area && location);
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getGetTimezoneAreaLocationKey(area, location) : null));
  const swrFn = () => getTimezoneAreaLocation(area, location, requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * @summary request the current time for a timezone.
 */
export const getTimezoneAreaLocationTxt = (
  area: string,
  location: string,
  options?: SecondParameter<typeof request>,
) => {
  return request<SuccessfulDateTimeTextResponseResponse>(
    { url: `/timezone/${area}/${location}.txt`, method: 'get' },
    options,
  );
};

export const getGetTimezoneAreaLocationTxtKey = (
  area: string,
  location: string,
) => [`/timezone/${area}/${location}.txt`] as const;

export type GetTimezoneAreaLocationTxtQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimezoneAreaLocationTxt>>
>;
export type GetTimezoneAreaLocationTxtQueryError =
  ErrorType<ErrorTextResponseResponse>;

/**
 * @summary request the current time for a timezone.
 */
export const useGetTimezoneAreaLocationTxt = <
  TError = ErrorType<ErrorTextResponseResponse>,
>(
  area: string,
  location: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof getTimezoneAreaLocationTxt>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    request?: SecondParameter<typeof request>;
  },
) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!(area && location);
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled ? getGetTimezoneAreaLocationTxtKey(area, location) : null);
  const swrFn = () =>
    getTimezoneAreaLocationTxt(area, location, requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * @summary request the current time for a timezone.
 */
export const getTimezoneAreaLocationRegion = (
  area: string,
  location: string,
  region: string,
  options?: SecondParameter<typeof request>,
) => {
  return request<SuccessfulDateTimeJsonResponseResponse>(
    { url: `/timezone/${area}/${location}/${region}`, method: 'get' },
    options,
  );
};

export const getGetTimezoneAreaLocationRegionKey = (
  area: string,
  location: string,
  region: string,
) => [`/timezone/${area}/${location}/${region}`] as const;

export type GetTimezoneAreaLocationRegionQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimezoneAreaLocationRegion>>
>;
export type GetTimezoneAreaLocationRegionQueryError =
  ErrorType<ErrorJsonResponseResponse>;

/**
 * @summary request the current time for a timezone.
 */
export const useGetTimezoneAreaLocationRegion = <
  TError = ErrorType<ErrorJsonResponseResponse>,
>(
  area: string,
  location: string,
  region: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof getTimezoneAreaLocationRegion>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    request?: SecondParameter<typeof request>;
  },
) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled =
    swrOptions?.enabled !== false && !!(area && location && region);
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled
        ? getGetTimezoneAreaLocationRegionKey(area, location, region)
        : null);
  const swrFn = () =>
    getTimezoneAreaLocationRegion(area, location, region, requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * @summary request the current time for a timezone.
 */
export const getTimezoneAreaLocationRegionTxt = (
  area: string,
  location: string,
  region: string,
  options?: SecondParameter<typeof request>,
) => {
  return request<SuccessfulDateTimeTextResponseResponse>(
    { url: `/timezone/${area}/${location}/${region}.txt`, method: 'get' },
    options,
  );
};

export const getGetTimezoneAreaLocationRegionTxtKey = (
  area: string,
  location: string,
  region: string,
) => [`/timezone/${area}/${location}/${region}.txt`] as const;

export type GetTimezoneAreaLocationRegionTxtQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimezoneAreaLocationRegionTxt>>
>;
export type GetTimezoneAreaLocationRegionTxtQueryError =
  ErrorType<ErrorTextResponseResponse>;

/**
 * @summary request the current time for a timezone.
 */
export const useGetTimezoneAreaLocationRegionTxt = <
  TError = ErrorType<ErrorTextResponseResponse>,
>(
  area: string,
  location: string,
  region: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof getTimezoneAreaLocationRegionTxt>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
    request?: SecondParameter<typeof request>;
  },
) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled =
    swrOptions?.enabled !== false && !!(area && location && region);
  const swrKey =
    swrOptions?.swrKey ??
    (() =>
      isEnabled
        ? getGetTimezoneAreaLocationRegionTxtKey(area, location, region)
        : null);
  const swrFn = () =>
    getTimezoneAreaLocationRegionTxt(area, location, region, requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * @summary request the current time based on the ip of the request. note: this is a "best guess" obtained from open-source data.
 */
export const getIp = (options?: SecondParameter<typeof request>) => {
  return request<SuccessfulDateTimeJsonResponseResponse>(
    { url: '/ip', method: 'get' },
    options,
  );
};

export const getGetIpKey = () => ['/ip'] as const;

export type GetIpQueryResult = NonNullable<Awaited<ReturnType<typeof getIp>>>;
export type GetIpQueryError = ErrorType<ErrorJsonResponseResponse>;

/**
 * @summary request the current time based on the ip of the request. note: this is a "best guess" obtained from open-source data.
 */
export const useGetIp = <
  TError = ErrorType<ErrorJsonResponseResponse>,
>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getIp>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
  request?: SecondParameter<typeof request>;
}) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getGetIpKey() : null));
  const swrFn = () => getIp(requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * @summary request the current time based on the ip of the request. note: this is a "best guess" obtained from open-source data.
 */
export const getIpTxt = (options?: SecondParameter<typeof request>) => {
  return request<SuccessfulDateTimeTextResponseResponse>(
    { url: '/ip.txt', method: 'get' },
    options,
  );
};

export const getGetIpTxtKey = () => ['/ip.txt'] as const;

export type GetIpTxtQueryResult = NonNullable<
  Awaited<ReturnType<typeof getIpTxt>>
>;
export type GetIpTxtQueryError = ErrorType<ErrorTextResponseResponse>;

/**
 * @summary request the current time based on the ip of the request. note: this is a "best guess" obtained from open-source data.
 */
export const useGetIpTxt = <
  TError = ErrorType<ErrorTextResponseResponse>,
>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof getIpTxt>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
  request?: SecondParameter<typeof request>;
}) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getGetIpTxtKey() : null));
  const swrFn = () => getIpTxt(requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * @summary request the current time based on the ip of the request. note: this is a "best guess" obtained from open-source data.
 */
export const getIpIpv4 = (
  ipv4: string,
  options?: SecondParameter<typeof request>,
) => {
  return request<SuccessfulDateTimeJsonResponseResponse>(
    { url: `/ip/${ipv4}`, method: 'get' },
    options,
  );
};

export const getGetIpIpv4Key = (ipv4: string) => [`/ip/${ipv4}`] as const;

export type GetIpIpv4QueryResult = NonNullable<
  Awaited<ReturnType<typeof getIpIpv4>>
>;
export type GetIpIpv4QueryError = ErrorType<ErrorJsonResponseResponse>;

/**
 * @summary request the current time based on the ip of the request. note: this is a "best guess" obtained from open-source data.
 */
export const useGetIpIpv4 = <TError = ErrorType<ErrorJsonResponseResponse>>(
  ipv4: string,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof getIpIpv4>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
    request?: SecondParameter<typeof request>;
  },
) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!ipv4;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getGetIpIpv4Key(ipv4) : null));
  const swrFn = () => getIpIpv4(ipv4, requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * @summary request the current time based on the ip of the request. note: this is a "best guess" obtained from open-source data.
 */
export const getIpIpv4Txt = (
  ipv4: string,
  options?: SecondParameter<typeof request>,
) => {
  return request<SuccessfulDateTimeTextResponseResponse>(
    { url: `/ip/${ipv4}.txt`, method: 'get' },
    options,
  );
};

export const getGetIpIpv4TxtKey = (ipv4: string) =>
  [`/ip/${ipv4}.txt`] as const;

export type GetIpIpv4TxtQueryResult = NonNullable<
  Awaited<ReturnType<typeof getIpIpv4Txt>>
>;
export type GetIpIpv4TxtQueryError = ErrorType<ErrorTextResponseResponse>;

/**
 * @summary request the current time based on the ip of the request. note: this is a "best guess" obtained from open-source data.
 */
export const useGetIpIpv4Txt = <TError = ErrorType<ErrorTextResponseResponse>>(
  ipv4: string,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof getIpIpv4Txt>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
    request?: SecondParameter<typeof request>;
  },
) => {
  const { swr: swrOptions, request: requestOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!ipv4;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getGetIpIpv4TxtKey(ipv4) : null));
  const swrFn = () => getIpIpv4Txt(ipv4, requestOptions);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions,
  );

  return {
    swrKey,
    ...query,
  };
};
